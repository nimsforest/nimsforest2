#!/bin/bash
#
# Git pre-commit hook for NimsForest
# This script runs various checks before allowing a commit.
#
# Installation:
#   Option 1: cp scripts/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit
#   Option 2: make install-hooks
#   Option 3: Use pre-commit framework: pip install pre-commit && pre-commit install
#
# To bypass (use sparingly): git commit --no-verify

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Track overall status
FAILED=0

# Print a section header
header() {
    echo -e "${BLUE}▶ $1${NC}"
}

# Print success message
success() {
    echo -e "${GREEN}✓ $1${NC}"
}

# Print failure message
fail() {
    echo -e "${RED}✗ $1${NC}"
    FAILED=1
}

# Print warning message
warn() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Get list of staged Go files
get_staged_go_files() {
    git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true
}

# Get list of all staged files
get_staged_files() {
    git diff --cached --name-only --diff-filter=ACM || true
}

echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${BLUE}              NimsForest Pre-Commit Checks                      ${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo ""

STAGED_GO_FILES=$(get_staged_go_files)
STAGED_FILES=$(get_staged_files)

# Skip if no Go files are staged
if [ -z "$STAGED_GO_FILES" ]; then
    echo -e "${YELLOW}No Go files staged for commit. Skipping Go-specific checks.${NC}"
else
    # ─────────────────────────────────────────────────────────────────────────────
    # Check 1: Go formatting (gofmt -s)
    # ─────────────────────────────────────────────────────────────────────────────
    header "Checking Go formatting (gofmt -s)..."

    UNFORMATTED=$(gofmt -s -l $STAGED_GO_FILES 2>&1 || true)
    if [ -n "$UNFORMATTED" ]; then
        fail "The following files are not properly formatted:"
        echo "$UNFORMATTED"
        echo ""
        echo "Run: gofmt -s -w <file>"
        echo "Or:  make fmt"
    else
        success "All Go files are properly formatted"
    fi

    # ─────────────────────────────────────────────────────────────────────────────
    # Check 2: Go vet
    # ─────────────────────────────────────────────────────────────────────────────
    header "Running go vet..."

    VET_OUTPUT=$(go vet ./... 2>&1 || true)
    if [ -n "$VET_OUTPUT" ]; then
        fail "go vet found issues:"
        echo "$VET_OUTPUT"
    else
        success "go vet passed"
    fi

    # ─────────────────────────────────────────────────────────────────────────────
    # Check 3: golangci-lint (if installed)
    # ─────────────────────────────────────────────────────────────────────────────
    header "Running golangci-lint..."

    if command -v golangci-lint &> /dev/null; then
        LINT_OUTPUT=$(golangci-lint run --timeout=5m 2>&1) || {
            fail "golangci-lint found issues:"
            echo "$LINT_OUTPUT"
        }
        if [ $FAILED -eq 0 ] || [ -z "$LINT_OUTPUT" ]; then
            success "golangci-lint passed"
        fi
    else
        warn "golangci-lint not installed, skipping..."
        echo "    Install: https://golangci-lint.run/usage/install/"
    fi

    # ─────────────────────────────────────────────────────────────────────────────
    # Check 4: Go build verification
    # ─────────────────────────────────────────────────────────────────────────────
    header "Verifying Go build..."

    BUILD_OUTPUT=$(go build ./... 2>&1) || {
        fail "Build failed:"
        echo "$BUILD_OUTPUT"
    }
    if [ $FAILED -eq 0 ] || [ -z "$BUILD_OUTPUT" ]; then
        success "Build verification passed"
    fi

    # ─────────────────────────────────────────────────────────────────────────────
    # Check 5: Go mod tidy check
    # ─────────────────────────────────────────────────────────────────────────────
    header "Checking go.mod and go.sum..."

    # Save current state
    cp go.mod go.mod.backup 2>/dev/null || true
    cp go.sum go.sum.backup 2>/dev/null || true

    go mod tidy 2>/dev/null

    # Check if files changed
    if ! diff -q go.mod go.mod.backup &>/dev/null || ! diff -q go.sum go.sum.backup &>/dev/null; then
        # Restore original files
        mv go.mod.backup go.mod 2>/dev/null || true
        mv go.sum.backup go.sum 2>/dev/null || true
        fail "go.mod or go.sum is not tidy"
        echo "    Run: go mod tidy"
    else
        rm -f go.mod.backup go.sum.backup 2>/dev/null || true
        success "go.mod and go.sum are tidy"
    fi

    # ─────────────────────────────────────────────────────────────────────────────
    # Check 6: Go tests (short mode)
    # ─────────────────────────────────────────────────────────────────────────────
    header "Running Go tests (short mode)..."

    TEST_OUTPUT=$(go test -race -short -timeout=60s ./... 2>&1) || {
        fail "Tests failed:"
        echo "$TEST_OUTPUT"
    }
    if [ $FAILED -eq 0 ]; then
        success "All tests passed"
    fi
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 7: Trailing whitespace
# ─────────────────────────────────────────────────────────────────────────────
header "Checking for trailing whitespace..."

WHITESPACE_FILES=""
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        if grep -qE '\s+$' "$file" 2>/dev/null; then
            WHITESPACE_FILES="$WHITESPACE_FILES $file"
        fi
    fi
done

if [ -n "$WHITESPACE_FILES" ]; then
    warn "Files with trailing whitespace:"
    echo "$WHITESPACE_FILES"
    echo "    Fix with: sed -i 's/[[:space:]]*$//' <file>"
else
    success "No trailing whitespace found"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 8: Large files
# ─────────────────────────────────────────────────────────────────────────────
header "Checking for large files..."

MAX_SIZE=1048576  # 1MB in bytes
LARGE_FILES=""
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        SIZE=$(wc -c < "$file" 2>/dev/null || echo 0)
        if [ "$SIZE" -gt "$MAX_SIZE" ]; then
            LARGE_FILES="$LARGE_FILES $file ($(numfmt --to=iec-i --suffix=B $SIZE 2>/dev/null || echo "${SIZE}B"))"
        fi
    fi
done

if [ -n "$LARGE_FILES" ]; then
    warn "Large files detected (>1MB):"
    echo "$LARGE_FILES"
else
    success "No large files detected"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 9: Check for debug statements
# ─────────────────────────────────────────────────────────────────────────────
header "Checking for debug statements..."

DEBUG_PATTERNS="fmt\.Print|log\.Print|panic\(|TODO:|FIXME:|HACK:|XXX:"
DEBUG_FILES=""
for file in $STAGED_GO_FILES; do
    if [ -f "$file" ]; then
        # Ignore test files for debug checks
        if [[ ! "$file" =~ _test\.go$ ]]; then
            MATCHES=$(grep -nE "$DEBUG_PATTERNS" "$file" 2>/dev/null | head -5 || true)
            if [ -n "$MATCHES" ]; then
                DEBUG_FILES="$DEBUG_FILES\n$file:\n$MATCHES"
            fi
        fi
    fi
done

if [ -n "$DEBUG_FILES" ]; then
    warn "Potential debug statements found (review before committing):"
    echo -e "$DEBUG_FILES"
else
    success "No obvious debug statements found"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 10: YAML syntax (for workflow files)
# ─────────────────────────────────────────────────────────────────────────────
YAML_FILES=$(echo "$STAGED_FILES" | grep -E '\.ya?ml$' || true)
if [ -n "$YAML_FILES" ]; then
    header "Checking YAML syntax..."

    YAML_ERRORS=""
    for file in $YAML_FILES; do
        if [ -f "$file" ]; then
            # Use Python for YAML validation if available
            if command -v python3 &> /dev/null; then
                ERROR=$(python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>&1) || {
                    YAML_ERRORS="$YAML_ERRORS\n$file: $ERROR"
                }
            fi
        fi
    done

    if [ -n "$YAML_ERRORS" ]; then
        fail "YAML syntax errors:"
        echo -e "$YAML_ERRORS"
    else
        success "YAML files are valid"
    fi
fi

# ─────────────────────────────────────────────────────────────────────────────
# Summary
# ─────────────────────────────────────────────────────────────────────────────
echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"

if [ $FAILED -eq 1 ]; then
    echo -e "${RED}Pre-commit checks FAILED${NC}"
    echo ""
    echo "Please fix the issues above before committing."
    echo "To bypass (use sparingly): git commit --no-verify"
    echo ""
    exit 1
else
    echo -e "${GREEN}All pre-commit checks PASSED${NC}"
    echo ""
    exit 0
fi
